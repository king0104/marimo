# 📝TIL

<br>

## 2025.03.11 (Tue)

### ✅ Today I've done

-   ERD 테이블 작성 시 데이터 속성 **VARCHAR**, **DATETIME**, **TIMESTAMP** 사용

<br>

### ❣️ Today I've Learned

#### **VARCHAR**

-   **설명:**  
    가변 길이의 문자열 데이터를 저장하기 위한 데이터 타입이다.
-   **특징:**
    -   저장할 문자열의 길이에 따라 메모리 사용량이 달라져, 고정 길이 문자열보다 효율적이다.
    -   사용자 이름, 이메일 주소, 설명 등 다양한 텍스트 데이터를 저장할 때 사용된다.
-   **사용 예:**
    -   사용자 입력값 저장, 주소, 메모 등의 데이터 저장

#### **DATETIME**

-   **설명:**  
    날짜와 시간을 함께 저장할 수 있는 데이터 타입이다.
-   **특징:**
    -   연, 월, 일, 시, 분, 초를 포함하며, 시간대 정보는 포함하지 않는다.
    -   시간대를 고려하지 않고 고정된 날짜와 시간 정보를 저장할 때 유용하다.
-   **사용 예:**
    -   특정 이벤트의 발생 시간, 예약 시간 등 사용자 지정 시간 기록에 적합

#### **TIMESTAMP**

-   **설명:**  
    UNIX 시간 기반의 값을 사용하여 날짜와 시간을 저장하는 데이터 타입이다.
-   **특징:**
    -   서버의 시간대를 기준으로 값이 저장되며, 자동으로 현재 시간으로 갱신되는 기능을 지원한다.
    -   데이터의 삽입 및 수정 시간을 추적하는데 유리하다.
-   **사용 예:**
    -   레코드 생성 시간, 마지막 수정 시간 자동 기록, 로그 관리

#### **DATETIME vs TIMESTAMP 비교**

-   **시간 저장 방식:**
    -   **DATETIME:**
        -   사용자가 지정한 날짜와 시간을 그대로 저장한다.
        -   시간대 변환이 적용되지 않아, 입력된 시간 그대로 유지된다.
    -   **TIMESTAMP:**
        -   서버의 시간대를 기준으로 값을 저장하며, 시간대에 따라 변환될 수 있다.
        -   데이터 삽입 및 업데이트 시 자동 갱신 기능을 제공한다.
-   **사용 목적:**
    -   **DATETIME:**
        -   사용자가 명시적으로 기록한 시간 정보를 보존할 필요가 있는 경우에 적합하다.
        -   예: 특정 이벤트나 약속 시간, 사용자 입력에 따른 날짜/시간 저장
    -   **TIMESTAMP:**
        -   레코드의 생성 및 수정 시점을 자동으로 기록하거나, 시간대에 따라 데이터 해석이 필요한 경우에 유리하다.
        -   예: 로그 기록, 데이터 변경 이력 관리

> **결론:**  
> ERD 설계 시 데이터의 특성과 사용 목적에 따라 올바른 데이터 타입을 선택하는 것이 중요하다. VARCHAR는 텍스트 데이터에, DATETIME은 고정된 시간 기록에, TIMESTAMP는 자동 시간 갱신 및 시간대 관리가 필요한 경우에 적합하다.

<br>
<br>

## 2025.03.10 (MON)

### ✅ Today I've done

-   식별자, 비식별자, 식별관계, 비식별관계계

<br>

### ❣️ Today I've Learned

### 식별자 (Identifier)

식별자는 데이터베이스의 테이블에서 각 행(레코드)을 유일하게 식별하는 속성을 의미합니다.  
주로 **기본 키(Primary Key)** 로 사용되며, 중복된 값이 허용되지 않습니다.

**예시:**

-   사용자 테이블의 `user_id`
-   제품 테이블의 `product_code`

---

### 비식별자 (Non-Identifier)

비식별자는 유일성을 보장하지 않는 속성으로, 데이터의 부가적인 정보를 저장하는 역할을 합니다.  
이들은 고유하지 않기 때문에 기본 키로 사용되지는 않지만, 데이터를 상세하게 표현하는 데 중요한 역할을 합니다.

**예시:**

-   사용자 테이블의 `name`, `email` (이메일이 고유할 수도 있지만, 일반적으로 식별자로 사용되진 않음)
-   제품 테이블의 `description`, `price`

---

### 식별관계 (Identifying Relationship)

식별관계는 자식 엔티티가 **부모 엔티티의 존재에 의존**하는 관계를 나타냅니다.  
자식 엔티티의 기본 키는 부모 엔티티의 기본 키를 포함하여 구성되므로, 부모 없이는 자식이 존재할 수 없습니다.

**특징:**

-   자식 엔티티의 기본 키에 부모 엔티티의 기본 키가 포함됨
-   부모 엔티티의 존재가 자식 엔티티의 존재에 필수적임
-   ER 다이어그램에서는 **실선**으로 표현됨

**예시:**

-   **주문(`Order`)** 과 **주문 상세(`OrderDetail`)**  
    주문 상세는 주문의 일부로, 주문 ID를 포함하여 고유하게 식별됩니다.

---

### 비식별관계 (Non-Identifying Relationship)

비식별관계는 자식 엔티티가 **독립적인 기본 키**를 가지며, 부모 엔티티와의 관계가 존재하더라도 그 관계가 기본 키에 포함되지 않는 경우를 말합니다.  
따라서 자식 엔티티는 부모 엔티티 없이도 독립적으로 존재할 수 있습니다.

**특징:**

-   자식 엔티티의 기본 키는 부모 엔티티의 기본 키를 포함하지 않음
-   부모와의 관계가 있으나, 자식 엔티티는 독립적으로 존재 가능함
-   ER 다이어그램에서는 **점선**으로 표현됨

**예시:**

-   **사용자(`User`)** 와 **프로필(`Profile`)**  
    프로필은 사용자의 정보를 참조하지만, 자체적으로 고유한 ID를 가지고 독립적으로 관리될 수 있습니다.

---

## 결론

식별자와 비식별자, 그리고 식별관계와 비식별관계는 데이터베이스 설계 및 ER 다이어그램 작성에 있어 핵심적인 개념입니다.  
이들을 잘 이해하면 엔티티 간의 관계를 명확하게 모델링하고 데이터 무결성을 효과적으로 유지할 수 있습니다.

<br>
<br>

## 2025.03.07 (FRI)

### ✅ Today I've done

-   국토교통부 자동차종합정보 API 조사

<br>

### ❣️ Today I've Learned

### 1. 개요

-   **API 명칭:** 국토교통부 자동차종합정보 API
-   **제공 기관:** 국토교통부 및 관련 정부 부처
-   **주요 목적:** 차량의 기본 정보(등록번호, 차대번호, 제조사 등)를 제공하여 차량 관련 데이터를 조회할 수 있음

### 2. 주요 특징

-   **데이터 언어:**
    -   기본적으로 한글로 응답 데이터를 제공함
    -   일부 입력 데이터나 특정 상황에 따라 영문 정보가 포함될 수 있음
-   **응답 구조:**
    -   **header:** API 호출 결과에 대한 상태 정보 제공
        -   예: `resultCode`, `resultMsg`
    -   **body:** 실제 차량 정보 데이터 포함
        -   `items`: 차량 정보 목록 (배열 형태)
        -   `pageNo`: 현재 페이지 번호 (페이징 처리 지원)
        -   `totalCount`: 전체 검색 결과 건수

### 3. JSON 응답 예시

```json
{
	"header": {
		"resultCode": "00",
		"resultMsg": "NORMAL SERVICE."
	},
	"body": {
		"items": [
			{
				"차량번호": "12가3456",
				"차대번호": "XXXXXXXXXX",
				"모델명": "SM5",
				"제조사": "르노삼성",
				"연식": "2018",
				"색상": "검정",
				"배기량": "2000",
				"연료종류": "가솔린",
				"검사일자": "2022-06-01"
			}
		],
		"pageNo": 1,
		"totalCount": 100
	}
}
```

<br>
<br>

## 2025.03.06 (THU)

### ✅ Today I've done

-   OBD2, ELM327, DTC

<br>

### ❣️ Today I've Learned

### OBD2 (On-Board Diagnostics 2)

-   **정의:** 차량의 센서 데이터를 수집하고 ECU의 상태를 모니터링하는 표준 진단 시스템
-   **주요 기능:**
    -   실시간 데이터 모니터링
    -   문제 발생 시 오류 코드 기록 및 진단
    -   배기가스 규제 준수를 위한 검사 지원
-   **특징:** 미국 등 여러 국가에서 의무화되어 다양한 차량에서 일관된 방식으로 사용

### ELM327

-   **정의:** OBD2 포트와 차량의 ECU 간 통신을 위한 인터페이스 칩 및 프로토콜
-   **주요 기능:**
    -   차량의 OBD2 데이터를 읽어들여 컴퓨터나 스마트폰에 전송
    -   블루투스, Wi-Fi, USB 등 다양한 연결 방식을 지원
    -   여러 제조사의 통신 프로토콜에 대응하여 광범위한 차량 호환성 제공

### DTC (Diagnostic Trouble Code)

-   **정의:** 차량의 ECU가 이상을 감지할 때 생성되는 오류 식별 코드
-   **주요 기능:**
    -   센서 데이터 이상 및 결함 감지 시 코드 기록
    -   오류의 원인을 파악하는 데 도움
    -   정비 및 수리 시 진단 정보로 활용

<br>
<br>

## 2025.03.05 (Wed)

### ✅ Today I've done

-   Mobile 환경에서 Redis Pub/Sub과 WebSocket 사용 기술 분석

<br>

### ❣️ Today I've Learned

### 1. Redis Pub/Sub의 역할 (주로 서버 사이드)

-   **서버 중심 메시징:**
    Redis Pub/Sub은 서버 간의 실시간 메시지 브로드캐스팅에 최적화되어 있습니다. 모바일 클라이언트가 직접 Redis에 접속하는 경우는 드물며, 보안 및 네트워크 제약 때문에 대부분의 경우 백엔드에서 Redis로 메시지를 받고 이를 다른 프로토콜(예: WebSocket)을 통해 전달합니다.

-   **높은 처리량 및 확장성:**
    Redis는 인메모리 방식으로 많은 양의 메시지를 빠르게 처리할 수 있어, 백엔드에서 대규모 이벤트 분배나 알림 시스템 구현에 적합합니다.

-   **비영속적 특성:**
    메시지가 지속되지 않으므로, 구독자가 연결되어 있어야 실시간 메시지를 받을 수 있습니다. 이 점은 모바일처럼 연결이 간헐적인 환경에서 직접 사용하기에는 한계가 있습니다.

### 2. WebSocket의 역할 (모바일 클라이언트와의 연결)

-   **양방향 통신:**
    WebSocket은 모바일 기기와 서버 간에 지속적이고 양방향 통신 채널을 제공합니다. 이를 통해 서버는 실시간으로 업데이트를 푸시할 수 있으며, 모바일 클라이언트는 즉각적으로 반응할 수 있습니다.

-   **연결 유지 및 재연결:**
    모바일 네트워크는 불안정할 수 있으므로, WebSocket 클라이언트는 연결 상태를 모니터링하고 필요 시 재연결 로직(heartbeat, ping/pong 등)을 구현해야 합니다.

-   **보안 및 프로토콜:**
    WebSocket은 WSS(보안 WebSocket)를 사용하여 HTTPS와 유사한 보안 수준을 제공하며, 이는 모바일 앱에서 중요하게 고려해야 할 요소입니다.

-   **자원 효율성:**
    지속적인 연결을 유지하는 동안 배터리와 데이터 사용을 최적화할 필요가 있습니다. 이는 전송되는 데이터의 양과 heartbeat 빈도 조절 등을 통해 관리합니다.

### 3. Redis Pub/Sub과 WebSocket의 통합 활용

-   **아키텍처 분리:**

    -   **백엔드:** Redis Pub/Sub을 사용하여 이벤트나 메시지를 받아 여러 서버 혹은 프로세스로 분산합니다.
    -   **메시지 브로커:** Redis에서 받은 메시지를 WebSocket 서버를 통해 모바일 클라이언트로 전달합니다.

-   **확장성 및 안정성:**

    -   Redis는 대량의 이벤트를 효율적으로 처리하며, WebSocket 서버는 클라이언트 연결을 관리합니다.
    -   만약 WebSocket 연결이 끊기더라도, 모바일 앱은 재연결 후 누락된 데이터를 REST API 등 다른 방법으로 복구할 수 있습니다.

-   **실시간 대응:**
    이 조합을 통해 서버는 높은 처리량의 메시지를 Redis로 분산 처리하고, 모바일 클라이언트는 WebSocket을 통해 실시간으로 데이터를 전달받아 사용자에게 빠른 피드백을 제공할 수 있습니다.

### 결론

-   **Redis Pub/Sub**은 주로 서버 사이드에서 높은 처리량과 확장성을 제공하는 메시지 브로커로 사용되며, 모바일 환경에서는 직접 연결보다는 백엔드 메시징 분배에 활용됩니다.
-   **WebSocket**은 모바일 기기와 서버 간의 안정적인 실시간 양방향 통신을 가능하게 하여, 불안정한 네트워크 환경에서도 사용자 경험을 향상시킵니다.
-   두 기술을 적절히 결합함으로써, 모바일 애플리케이션에서 실시간 데이터 전달과 효율적인 리소스 관리를 동시에 달성할 수 있습니다.

<br>
<br>

## 2025.03.04 (Tue)

### ✅ Today I've done

-   Kafka vs Redis pub/sub

<br>

### ❣️ Today I've Learned

**1. Apache Kafka**

-   **아키텍처:** 분산 시스템, 로그 기반 메시지 저장소
-   **특징:**
    -   높은 처리량과 낮은 지연시간
    -   메시지 지속 저장 및 재생 기능
    -   내결함성 및 확장성 우수
-   **사용 사례:** 이벤트 소싱, 로그 집계, 실시간 스트리밍 분석

**2. Redis Pub/Sub**

-   **아키텍처:** 인메모리 기반 메시지 브로커
-   **특징:**
    -   매우 낮은 지연시간과 빠른 메시지 전달
    -   메시지가 지속되지 않으며, 구독자에게 실시간으로 전달 후 사라짐
    -   상대적으로 간단하고 설정이 쉬움
-   **사용 사례:** 실시간 채팅, 알림 시스템, 간단한 이벤트 브로드캐스팅

**3. 비교 요약**

-   **확장성:**
    -   Kafka는 파티셔닝과 클러스터링을 통한 수평 확장이 용이
    -   Redis는 단순하지만 대규모 처리에는 별도 클러스터링 구성이 필요
-   **내구성:**
    -   Kafka는 메시지 지속 저장을 통해 내구성과 재생 기능 제공
    -   Redis Pub/Sub은 메시지가 영속적으로 저장되지 않음
-   **지연시간:**
    -   Redis는 인메모리 처리로 극히 낮은 지연시간 제공
    -   Kafka는 디스크 I/O가 포함되지만 최적화된 환경에서 충분히 낮은 지연시간 유지
-   **복잡성:**
    -   Kafka는 설치 및 운영 관리가 복잡할 수 있음
    -   Redis Pub/Sub은 간단하게 구성하고 사용할 수 있음

**4. 결론**

-   **Kafka:** 신뢰성 높은 메시지 저장, 재생 및 대규모 데이터 스트리밍 처리에 적합
-   **Redis Pub/Sub:** 경량 실시간 메시징에 적합하며, 단순한 이벤트 브로드캐스팅에 효과적

<br>
<br>
```
