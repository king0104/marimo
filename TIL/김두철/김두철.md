# 📝TIL

<br>

## 2025.03.07 (FRI)

### ✅ Today I've done

-   국토교통부 자동차종합정보 API 조사

<br>

### ❣️ Today I've Learned

### 1. 개요

-   **API 명칭:** 국토교통부 자동차종합정보 API
-   **제공 기관:** 국토교통부 및 관련 정부 부처
-   **주요 목적:** 차량의 기본 정보(등록번호, 차대번호, 제조사 등)를 제공하여 차량 관련 데이터를 조회할 수 있음

### 2. 주요 특징

-   **데이터 언어:**
    -   기본적으로 한글로 응답 데이터를 제공함
    -   일부 입력 데이터나 특정 상황에 따라 영문 정보가 포함될 수 있음
-   **응답 구조:**
    -   **header:** API 호출 결과에 대한 상태 정보 제공
        -   예: `resultCode`, `resultMsg`
    -   **body:** 실제 차량 정보 데이터 포함
        -   `items`: 차량 정보 목록 (배열 형태)
        -   `pageNo`: 현재 페이지 번호 (페이징 처리 지원)
        -   `totalCount`: 전체 검색 결과 건수

### 3. JSON 응답 예시

```json
{
	"header": {
		"resultCode": "00",
		"resultMsg": "NORMAL SERVICE."
	},
	"body": {
		"items": [
			{
				"차량번호": "12가3456",
				"차대번호": "XXXXXXXXXX",
				"모델명": "SM5",
				"제조사": "르노삼성",
				"연식": "2018",
				"색상": "검정",
				"배기량": "2000",
				"연료종류": "가솔린",
				"검사일자": "2022-06-01"
			}
		],
		"pageNo": 1,
		"totalCount": 100
	}
}
```

<br>
<br>

## 2025.03.06 (THU)

### ✅ Today I've done

-   OBD2, ELM327, DTC

<br>

### ❣️ Today I've Learned

### OBD2 (On-Board Diagnostics 2)

-   **정의:** 차량의 센서 데이터를 수집하고 ECU의 상태를 모니터링하는 표준 진단 시스템
-   **주요 기능:**
    -   실시간 데이터 모니터링
    -   문제 발생 시 오류 코드 기록 및 진단
    -   배기가스 규제 준수를 위한 검사 지원
-   **특징:** 미국 등 여러 국가에서 의무화되어 다양한 차량에서 일관된 방식으로 사용

### ELM327

-   **정의:** OBD2 포트와 차량의 ECU 간 통신을 위한 인터페이스 칩 및 프로토콜
-   **주요 기능:**
    -   차량의 OBD2 데이터를 읽어들여 컴퓨터나 스마트폰에 전송
    -   블루투스, Wi-Fi, USB 등 다양한 연결 방식을 지원
    -   여러 제조사의 통신 프로토콜에 대응하여 광범위한 차량 호환성 제공

### DTC (Diagnostic Trouble Code)

-   **정의:** 차량의 ECU가 이상을 감지할 때 생성되는 오류 식별 코드
-   **주요 기능:**
    -   센서 데이터 이상 및 결함 감지 시 코드 기록
    -   오류의 원인을 파악하는 데 도움
    -   정비 및 수리 시 진단 정보로 활용

<br>
<br>

## 2025.03.05 (Wed)

### ✅ Today I've done

-   Mobile 환경에서 Redis Pub/Sub과 WebSocket 사용 기술 분석

<br>

### ❣️ Today I've Learned

### 1. Redis Pub/Sub의 역할 (주로 서버 사이드)

-   **서버 중심 메시징:**
    Redis Pub/Sub은 서버 간의 실시간 메시지 브로드캐스팅에 최적화되어 있습니다. 모바일 클라이언트가 직접 Redis에 접속하는 경우는 드물며, 보안 및 네트워크 제약 때문에 대부분의 경우 백엔드에서 Redis로 메시지를 받고 이를 다른 프로토콜(예: WebSocket)을 통해 전달합니다.

-   **높은 처리량 및 확장성:**
    Redis는 인메모리 방식으로 많은 양의 메시지를 빠르게 처리할 수 있어, 백엔드에서 대규모 이벤트 분배나 알림 시스템 구현에 적합합니다.

-   **비영속적 특성:**
    메시지가 지속되지 않으므로, 구독자가 연결되어 있어야 실시간 메시지를 받을 수 있습니다. 이 점은 모바일처럼 연결이 간헐적인 환경에서 직접 사용하기에는 한계가 있습니다.

### 2. WebSocket의 역할 (모바일 클라이언트와의 연결)

-   **양방향 통신:**
    WebSocket은 모바일 기기와 서버 간에 지속적이고 양방향 통신 채널을 제공합니다. 이를 통해 서버는 실시간으로 업데이트를 푸시할 수 있으며, 모바일 클라이언트는 즉각적으로 반응할 수 있습니다.

-   **연결 유지 및 재연결:**
    모바일 네트워크는 불안정할 수 있으므로, WebSocket 클라이언트는 연결 상태를 모니터링하고 필요 시 재연결 로직(heartbeat, ping/pong 등)을 구현해야 합니다.

-   **보안 및 프로토콜:**
    WebSocket은 WSS(보안 WebSocket)를 사용하여 HTTPS와 유사한 보안 수준을 제공하며, 이는 모바일 앱에서 중요하게 고려해야 할 요소입니다.

-   **자원 효율성:**
    지속적인 연결을 유지하는 동안 배터리와 데이터 사용을 최적화할 필요가 있습니다. 이는 전송되는 데이터의 양과 heartbeat 빈도 조절 등을 통해 관리합니다.

### 3. Redis Pub/Sub과 WebSocket의 통합 활용

-   **아키텍처 분리:**

    -   **백엔드:** Redis Pub/Sub을 사용하여 이벤트나 메시지를 받아 여러 서버 혹은 프로세스로 분산합니다.
    -   **메시지 브로커:** Redis에서 받은 메시지를 WebSocket 서버를 통해 모바일 클라이언트로 전달합니다.

-   **확장성 및 안정성:**

    -   Redis는 대량의 이벤트를 효율적으로 처리하며, WebSocket 서버는 클라이언트 연결을 관리합니다.
    -   만약 WebSocket 연결이 끊기더라도, 모바일 앱은 재연결 후 누락된 데이터를 REST API 등 다른 방법으로 복구할 수 있습니다.

-   **실시간 대응:**
    이 조합을 통해 서버는 높은 처리량의 메시지를 Redis로 분산 처리하고, 모바일 클라이언트는 WebSocket을 통해 실시간으로 데이터를 전달받아 사용자에게 빠른 피드백을 제공할 수 있습니다.

### 결론

-   **Redis Pub/Sub**은 주로 서버 사이드에서 높은 처리량과 확장성을 제공하는 메시지 브로커로 사용되며, 모바일 환경에서는 직접 연결보다는 백엔드 메시징 분배에 활용됩니다.
-   **WebSocket**은 모바일 기기와 서버 간의 안정적인 실시간 양방향 통신을 가능하게 하여, 불안정한 네트워크 환경에서도 사용자 경험을 향상시킵니다.
-   두 기술을 적절히 결합함으로써, 모바일 애플리케이션에서 실시간 데이터 전달과 효율적인 리소스 관리를 동시에 달성할 수 있습니다.

<br>
<br>

## 2025.03.04 (Tue)

### ✅ Today I've done

-   Kafka vs Redis pub/sub

<br>

### ❣️ Today I've Learned

**1. Apache Kafka**

-   **아키텍처:** 분산 시스템, 로그 기반 메시지 저장소
-   **특징:**
    -   높은 처리량과 낮은 지연시간
    -   메시지 지속 저장 및 재생 기능
    -   내결함성 및 확장성 우수
-   **사용 사례:** 이벤트 소싱, 로그 집계, 실시간 스트리밍 분석

**2. Redis Pub/Sub**

-   **아키텍처:** 인메모리 기반 메시지 브로커
-   **특징:**
    -   매우 낮은 지연시간과 빠른 메시지 전달
    -   메시지가 지속되지 않으며, 구독자에게 실시간으로 전달 후 사라짐
    -   상대적으로 간단하고 설정이 쉬움
-   **사용 사례:** 실시간 채팅, 알림 시스템, 간단한 이벤트 브로드캐스팅

**3. 비교 요약**

-   **확장성:**
    -   Kafka는 파티셔닝과 클러스터링을 통한 수평 확장이 용이
    -   Redis는 단순하지만 대규모 처리에는 별도 클러스터링 구성이 필요
-   **내구성:**
    -   Kafka는 메시지 지속 저장을 통해 내구성과 재생 기능 제공
    -   Redis Pub/Sub은 메시지가 영속적으로 저장되지 않음
-   **지연시간:**
    -   Redis는 인메모리 처리로 극히 낮은 지연시간 제공
    -   Kafka는 디스크 I/O가 포함되지만 최적화된 환경에서 충분히 낮은 지연시간 유지
-   **복잡성:**
    -   Kafka는 설치 및 운영 관리가 복잡할 수 있음
    -   Redis Pub/Sub은 간단하게 구성하고 사용할 수 있음

**4. 결론**

-   **Kafka:** 신뢰성 높은 메시지 저장, 재생 및 대규모 데이터 스트리밍 처리에 적합
-   **Redis Pub/Sub:** 경량 실시간 메시징에 적합하며, 단순한 이벤트 브로드캐스팅에 효과적

<br>
<br>
```
