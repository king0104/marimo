# 📝 TIL

<br>

## 2025.04.01 (Tue)

### ✅ Today I've done

- Chatbot UI 수정
- Flutter로 ChatGPT 4o 모델 사용하여 차량 고장 정보 분석
- 대화형 AI 에이전트로 사용할 수 있는 텍스트 추론/생성 모델 파인튜닝

<br>

### ❣️ Today I've Learned

- UI 변경 시 사용자 경험(UX)을 고려한 세부 디자인 수정의 중요성을 재확인했습니다.
- Flutter와 ChatGPT 4o 모델을 연동하는 과정에서 발생하는 데이터 처리 및 통신 이슈 해결 방법을 익혔습니다.
- 텍스트 모델 파인튜닝 시 데이터 전처리와 하이퍼파라미터 튜닝의 차이가 결과에 미치는 영향을 체감하며, 지속적인 실험의 필요성을 느꼈습니다.

<br>
<br>

## 2025.03.31 (Mon)

### ✅ Today I've done

- 음성 인식 AI 모델을 Google Colab으로 구축

<br>

### ❣️ Today I've Learned

- Google Colab 환경에서 음성 인식 모델을 구동하며, 클라우드 환경의 장점과 한계를 직접 경험했습니다.
- 데이터 전처리와 음성 신호의 특징 추출 방법에 대해 심도 있게 공부할 수 있었습니다.
- 모델의 학습 과정 중 발생한 오류 로그를 분석하며, 디버깅 스킬을 향상시킬 수 있는 기회가 되었습니다.

<br>
<br>

## 2025.03.28 (Fri)

### ✅ Today I've done

- jupyter GPU 서버
- 온디바이스 AI 경량 모델 Flutter에서 구축하기

<br>

### ❣️ Today I've Learned

- **GPU 서버 최적화:** Jupyter를 활용해 GPU 서버를 효율적으로 구성하고, 연산 자원을 최적화하는 방법에 대해 배웠습니다.
- **Flutter와 AI 통합:** Flutter 앱 내에서 온디바이스 AI 경량 모델을 구축하는 과정에서, 경량화된 모델이 모바일 환경에서 어떻게 빠르게 실행될 수 있는지 확인했습니다.
- **실제 적용 경험:** 이 두 작업을 통해, AI 모델 배포와 서버 환경 구축에 관한 실무적인 문제 해결 방법을 직접 체험하며 많은 인사이트를 얻었습니다.

<br>
<br>

## 2025.03.27 (Thu)

### ✅ Today I've done

- Flutter 인증/인가 개발
- Flutter 전역 로그인 설정
- Flutter services 폴더에 API 로직 처리

<br>

### ❣️ Today I've Learned

- Flutter 환경에서 인증 및 인가를 구현하는 과정에서 앱의 보안 구조를 체계적으로 설계하는 방법을 익혔습니다. 전역 로그인 설정을 통해 사용자 경험을 개선하는 방법과, API 로직을 별도 서비스 폴더로 분리함으로써 코드 관리의 중요성을 다시 한 번 깨달았습니다.

<br>
<br>

## 2025.03.26 (Wed)

### ✅ Today I've done

- Servlet Filter, Spring Interceptor

<br>

### ❣️ Today I've Learned

- Servlet Filter와 Spring Interceptor의 차이점 및 사용 목적에 대해 심도 있게 이해했습니다. 이를 통해 요청과 응답의 흐름을 효과적으로 제어하는 방법과, 상황에 맞는 필터와 인터셉터의 선택 기준을 배울 수 있었습니다.

<br>
<br>

## 2025.03.25 (Tue)

### ✅ Today I've done

- Spring Security, JWT 개발

<br>

### ❣️ Today I've Learned

- Spring Security와 JWT를 활용한 인증 방식에 대해 실습하면서, 보안 토큰의 생성과 검증 과정 및 이를 통한 사용자 인증 절차에 대해 명확히 이해하게 되었습니다. 실제 서비스에 적용할 때 고려해야 할 보안 포인트도 점검해보는 기회였습니다.

<br>
<br>

## 2025.03.24 (Mon)

### ✅ Today I've done

- JPA
- create, of 메서드, DTO 컨벤션

<br>

### ❣️ Today I've Learned

- JPA를 활용한 데이터베이스 연동 과정과 함께, 객체 생성 및 데이터 전송에 있어서 create, of 메서드를 통한 깔끔한 객체 생성을 학습했습니다. 또한, DTO 컨벤션을 통해 코드의 가독성과 유지보수성을 높이는 방법에 대해 고민해보았습니다.

<br>
<br>

## 2025.03.21 (Fri)

### ✅ Today I've done

- 발표 기획
- 발표 장표 작성

<br>

### ❣️ Today I've Learned

- 오늘 다같이 발표 기획을 하였고, 장표를 작성하였습니다.
- Canva 툴을 사용하였고, 발표 사전준비 할 수 있게 세팅하여 효과적으로 발표 기획을 준비할 수 있었습니다.

<br>
<br>

## 2025.03.20 (Thu)

### ✅ Today I've done

- 발표 기획
- 발표 장표 작성

<br>

### ❣️ Today I've Learned

- 오늘 다같이 발표 기획을 하였고, 장표를 작성하였습니다.
- Canva 툴을 사용하였고, 발표 사전준비 할 수 있게 세팅하여 효과적으로 발표 기획을 준비할 수 있었습니다.

<br>
<br>

## 2025.03.19 (Wed)

### ✅ Today I've done

- Jenkins CI/CD 계속
- 엠로 코딩테스트
- EC2 서버 과부하로 인해 다운돼서 복구

<br>

### ❣️ Today I've Learned

- EC2 서버 과부하 발생 후 복구 하는 법에 대해서 찾아보고 배웠습니다.

<br>
<br>

## 2025.03.18 (Tue)

### ✅ Today I've done

- **Jenkins → AWS EC2 (API 서버) 배포 설정**

  - Jenkins Credentials에 SSH Key 등록
  - API 서버와 Jenkins 서버 간 SSH 연결 설정
  - Jenkins에서 Docker + Nginx + HTTPS를 활용한 CI/CD 구축

- **Nginx 최신 버전 설치 및 SSL 인증서 설정**

  - 기존 Nginx 제거 후 최신 버전 재설치
  - Certbot을 활용한 HTTPS 설정

- **Docker + Docker-Compose를 활용한 API 서버 배포**
  - Spring Boot 프로젝트 Docker 컨테이너화
  - Docker-Compose로 MySQL과 함께 실행

<br>

### ❣️ Today I've Learned

- **Jenkins에서 환경 변수 관리 방법**

  - Jenkins Credentials을 활용해 보안성을 유지하며 환경 변수 관리
  - `.env` 파일을 활용해 Docker-Compose에서 로드
  - Jenkins Pipeline에서 환경 변수를 직접 주입하는 방법

- **Nginx 리버스 프록시 설정과 HTTPS 적용**

  - `proxy_pass`를 이용한 API 서버 연동
  - Certbot을 활용한 SSL 인증서 자동 발급

- **Jenkinsfile vs Jenkins UI 설정 비교**

  - Jenkinsfile을 사용하면 **버전 관리 및 자동화**가 용이
  - Jenkins UI에서 설정하면 **빠르게 적용 가능하지만 유지보수 어려움**

- **AWS EC2 간 SSH Key 등록 및 연결 문제 해결**
  - `authorized_keys`에 여러 SSH Key 등록 가능
  - 보안 그룹 및 인바운드 설정 확인 필수

<br>
<br>

## 2025.03.17 (Mon)

### ✅ Today I've done

- Jenkins 서버를 기존 서버에서 분리하여 다른 AWS EC2 인스턴스에서 CI/CD 구축

<br>

### ❣️ Today I've Learned

- **Jenkins 분리의 필요성**  
  기존 애플리케이션 서버와 Jenkins 서버를 분리함으로써, 서버 자원을 효율적으로 활용하고 CI/CD 작업으로 인한 애플리케이션 성능 저하를 방지할 수 있다는 점을 확인했습니다.

- **AWS EC2에 Jenkins 설치 및 구성**

  - EC2 인스턴스 생성 후, Jenkins 설치 및 초기 보안 설정을 진행했습니다.
  - Jenkins 관리 콘솔에서 필요한 플러그인(Git, Slack notifications 등)을 설치하고, 관리 용이성을 높였습니다.

- **CI/CD 파이프라인 최적화**

  - 빌드와 배포 과정을 자동화하여, 코드 변경 시 빠른 테스트와 배포가 가능하도록 파이프라인을 개선했습니다.
  - 빌드 로깅 및 환경 변수를 체계적으로 관리하여, 문제가 발생했을 때 손쉽게 디버깅이 가능하도록 설정했습니다.

- **보안 고려 사항**

  - Jenkins Dashboard와 서버 접근 시 HTTPS(SSL 인증서)를 적용하여 보안을 강화했습니다.
  - IAM 역할 및 보안 그룹(Security Group)을 통해 Jenkins 서버에 대한 권한 관리를 상세하게 설정했습니다.

- **확장성 확보**
  - 빌드 에이전트(노드)를 추가로 두어, 병렬 빌드가 가능하도록 확장성 있는 CI/CD 환경을 구축하는 방법을 학습했습니다.
  - Jenkins와 AWS 서비스(ECR, S3 등)의 연동을 통해 배포 옵션을 다양화할 수 있음을 배웠습니다.

<br>
<br>

## 2025.03.14 (Fri)

### ✅ Today I've done

- RESTful API 규칙에 대해 학습
- JWT, Redis, OAuth2.0 등을 활용한 인증/인가 설계 방법 공부

<br>

### ❣️ Today I've Learned

1. RESTful API 규칙

자원(Resource)과 메서드(Method) 분리: 자원을 명확히 식별할 수 있는 URL을 설계하고, 자원에 대한 동작은 HTTP 메서드(GET, POST, PUT, DELETE 등)로 표현한다.
URL 계층 구조: 복수형 사용, 소문자 사용, 슬래시(/)로 계층 구조를 나타내도록 설계한다. 예) /users/123/posts
표준 HTTP 상태 코드 활용: 요청 성공(200, 201), 클라이언트 오류(400, 404), 서버 오류(500) 등 상황에 맞는 상태 코드를 반환한다.
무상태성(Stateless): 클라이언트와 서버의 통신을 위해 세션 정보를 서버가 별도로 보관하지 않고, 각 요청은 독립적으로 처리되도록 한다.

2. JWT (JSON Web Token)

구성 요소: 헤더(Header), 페이로드(Payload), 시그니처(Signature) 세 부분으로 구성되며 각각 Base64로 인코딩된다.
장점: 서버 상태를 관리할 필요 없이 토큰 검증만으로 인증/인가를 처리할 수 있어 무상태성과 확장성에 유리하다.
보안 고려: 토큰 내 정보는 노출될 수 있으므로 민감한 정보는 넣지 않고, HTTPS를 통해 통신하며 만료 기한(Exp) 설정과 토큰 재발급 로직이 중요하다.

3. Redis를 활용한 인증/인가 관리

세션/토큰 관리: Redis를 캐시 형태로 사용해 세션 정보나 토큰의 유효성을 빠르게 확인할 수 있다.
블랙리스트 구현: 로그아웃했거나 무효화된 토큰을 Redis 블랙리스트에 저장해, 해당 토큰이 다시 사용되지 않도록 검증할 수 있다.
TTL(Time To Live) 설정: Redis에 저장된 토큰에게 만료 시간을 부여해 자동으로 데이터가 정리되도록 할 수 있다.

4. OAuth2.0

역할 분담:
Resource Owner(유저), Resource Server(API 서버), Authorization Server(인증 서버)가 분리되어 역할을 수행한다.
Grant Type 종류: Authorization Code, Implicit, Resource Owner Password Credentials, Client Credentials 등이 있으며, 상황에 맞춰 적절히 선택한다.
Scope와 Access Token: 요청 범위를 명시해 최소 권한만 허용하며, Access Token을 활용해 자원 서버에 접근한다.
Refresh Token: Access Token 만료 시, Refresh Token으로 새로운 Access Token을 발급받아 재인증 없이 연속성을 유지한다.

<br>
<br>

## 2025.03.13 (Thu)

### ✅ Today I've done

- 스프링 JPA, QueryDSL 공부
- Flutter shadcn 패키지 서치

<br>

### ❣️ Today I've Learned

스프링 JPA와 QueryDSL의 기본 동작 방식 및 주요 기능을 익혔습니다.
Spring Data JPA와 QueryDSL을 함께 사용하는 방법을 학습했고, 이를 통해 ORM 활용 시 원하는 쿼리를 더 유연하게 작성할 수 있음을 알게 되었습니다.
Flutter 환경에서 shadcn 패키지를 찾고 사용을 검토했습니다.
UI 컴포넌트를 좀 더 빠르고 편리하게 적용하기 위해 패키지를 검색하고, 사용 예시와 적용 방법에 대해 간략히 살펴보았습니다.

<br>
<br>

## 2025.03.12 (Wed)

### ✅ Today I've done

- ERD 관련 미팅 자료를 정리하고, 주요 피드백 및 개선 의견을 분석하여 기록함.
- 회원, 알림, 차량, 소모품, 주유소 등 다양한 테이블의 스키마 개선점을 도출하고 논의함.
- 미팅에서 나온 의견을 바탕으로 DB 스키마 및 데이터 관리 방안을 구체화하는 작업을 진행함.

<br>

### ❣️ Today I've Learned

- **ERD 피드백 – Member 테이블**

  - "내 주유 기준" 설정은 INT 대신 TINYINT로 최적화해 용량을 줄이고, 계정 생성일시는 일자(Date)와 일시(DATETIME)를 구분해 관리하는 것이 좋다는 피드백을 받음.
  - HTTPS 프로토콜을 사용하면 전송 과정에서 자동 암호화되므로, 프론트엔드에서 별도 암호화 작업은 불필요하며 SHA-256 정도면 충분함.

- **ERD 피드백 – Notification 테이블**

  - 알림 확인 여부뿐만 아니라 **읽은 시간**을 기록하는 필드를 추가해 알림 상태를 명확히 추적할 필요가 있음.
  - 알림의 원인 파악을 위해 OBD2-DTC 연결 테이블과 연계하는 방안도 제안됨.
  - FCM 토큰은 Notification 테이블이 아니라 유저(User) 테이블에 JSON 배열 형태로 저장해 관리하는 것이 고려됨.

- **미팅 내용 – 회원 & 문의사항**

  - 회원 탈퇴 여부는 is null 체크 대신 명시적인 탈퇴 상태 컬럼으로 관리하고, 소셜 로그인 제공자 도메인은 VARCHAR로 저장해 JPA 매핑 시 enum으로 처리하는 방식이 제안됨.
  - 문의 상태는 간단하게 P, A, C와 같은 코드로 관리해 통일성을 높이도록 논의됨.

- **미팅 내용 – 차량, 진단 시스템 & 소모품**

  - 차량 테이블은 제조사명을 코드 리스트로 관리하고, 차량번호 형식을 엄격하게 검증하며, 연료타입도 enum 또는 코드로 관리한다.
  - **연료통 사이즈** 칼럼 추가로 연료 잔량을 보다 정밀하게 측정할 수 있도록 개선함.
  - 차량 진단 시스템의 로우 데이터 테이블 명칭은 `on_board_diagnostics` 등으로 통일하고, OBD2-DTC 연결 테이블은 고유 ID와 처리 상태, 세부 내용을 포함해 오류 원인 추적에 활용하도록 제안됨.
  - 차량 소모품은 다대다 관계를 명확히 하고, 가격 변동 및 교체주기 등 정책 기반 데이터를 관리할 수 있도록 중간 매핑 테이블 도입을 논의함.

- **미팅 내용 – 주유소 및 기타 정보 관리**
  - 주유소 정보는 하루 6회 데이터 갱신을 고려해, 기존 데이터를 삭제한 후 insert하는 방식으로 관리하는 것이 추천됨.
  - 유가 정보는 하루 4회 최신 정보를 반영하며, 기록 보존 및 필요 시 데이터 삭제 전략에 대해 검토함.
  - 정비소, 세차장 등의 가격 정보 제공 방식에 대한 추가 논의가 필요함.

<br>
<br>

## 2025.03.11 (Tue)

### ✅ Today I've done

- ERD 테이블 작성 시 데이터 속성 **VARCHAR**, **DATETIME**, **TIMESTAMP** 사용

<br>

### ❣️ Today I've Learned

#### **VARCHAR**

- **설명:**  
  가변 길이의 문자열 데이터를 저장하기 위한 데이터 타입이다.
- **특징:**
  - 저장할 문자열의 길이에 따라 메모리 사용량이 달라져, 고정 길이 문자열보다 효율적이다.
  - 사용자 이름, 이메일 주소, 설명 등 다양한 텍스트 데이터를 저장할 때 사용된다.
- **사용 예:**
  - 사용자 입력값 저장, 주소, 메모 등의 데이터 저장

#### **DATETIME**

- **설명:**  
  날짜와 시간을 함께 저장할 수 있는 데이터 타입이다.
- **특징:**
  - 연, 월, 일, 시, 분, 초를 포함하며, 시간대 정보는 포함하지 않는다.
  - 시간대를 고려하지 않고 고정된 날짜와 시간 정보를 저장할 때 유용하다.
- **사용 예:**
  - 특정 이벤트의 발생 시간, 예약 시간 등 사용자 지정 시간 기록에 적합

#### **TIMESTAMP**

- **설명:**  
  UNIX 시간 기반의 값을 사용하여 날짜와 시간을 저장하는 데이터 타입이다.
- **특징:**
  - 서버의 시간대를 기준으로 값이 저장되며, 자동으로 현재 시간으로 갱신되는 기능을 지원한다.
  - 데이터의 삽입 및 수정 시간을 추적하는데 유리하다.
- **사용 예:**
  - 레코드 생성 시간, 마지막 수정 시간 자동 기록, 로그 관리

#### **DATETIME vs TIMESTAMP 비교**

- **시간 저장 방식:**
  - **DATETIME:**
    - 사용자가 지정한 날짜와 시간을 그대로 저장한다.
    - 시간대 변환이 적용되지 않아, 입력된 시간 그대로 유지된다.
  - **TIMESTAMP:**
    - 서버의 시간대를 기준으로 값을 저장하며, 시간대에 따라 변환될 수 있다.
    - 데이터 삽입 및 업데이트 시 자동 갱신 기능을 제공한다.
- **사용 목적:**
  - **DATETIME:**
    - 사용자가 명시적으로 기록한 시간 정보를 보존할 필요가 있는 경우에 적합하다.
    - 예: 특정 이벤트나 약속 시간, 사용자 입력에 따른 날짜/시간 저장
  - **TIMESTAMP:**
    - 레코드의 생성 및 수정 시점을 자동으로 기록하거나, 시간대에 따라 데이터 해석이 필요한 경우에 유리하다.
    - 예: 로그 기록, 데이터 변경 이력 관리

> **결론:**  
> ERD 설계 시 데이터의 특성과 사용 목적에 따라 올바른 데이터 타입을 선택하는 것이 중요하다. VARCHAR는 텍스트 데이터에, DATETIME은 고정된 시간 기록에, TIMESTAMP는 자동 시간 갱신 및 시간대 관리가 필요한 경우에 적합하다.

<br>
<br>

## 2025.03.10 (MON)

### ✅ Today I've done

- 식별자, 비식별자, 식별관계, 비식별관계계

<br>

### ❣️ Today I've Learned

### 식별자 (Identifier)

식별자는 데이터베이스의 테이블에서 각 행(레코드)을 유일하게 식별하는 속성을 의미합니다.  
주로 **기본 키(Primary Key)** 로 사용되며, 중복된 값이 허용되지 않습니다.

**예시:**

- 사용자 테이블의 `user_id`
- 제품 테이블의 `product_code`

---

### 비식별자 (Non-Identifier)

비식별자는 유일성을 보장하지 않는 속성으로, 데이터의 부가적인 정보를 저장하는 역할을 합니다.  
이들은 고유하지 않기 때문에 기본 키로 사용되지는 않지만, 데이터를 상세하게 표현하는 데 중요한 역할을 합니다.

**예시:**

- 사용자 테이블의 `name`, `email` (이메일이 고유할 수도 있지만, 일반적으로 식별자로 사용되진 않음)
- 제품 테이블의 `description`, `price`

---

### 식별관계 (Identifying Relationship)

식별관계는 자식 엔티티가 **부모 엔티티의 존재에 의존**하는 관계를 나타냅니다.  
자식 엔티티의 기본 키는 부모 엔티티의 기본 키를 포함하여 구성되므로, 부모 없이는 자식이 존재할 수 없습니다.

**특징:**

- 자식 엔티티의 기본 키에 부모 엔티티의 기본 키가 포함됨
- 부모 엔티티의 존재가 자식 엔티티의 존재에 필수적임
- ER 다이어그램에서는 **실선**으로 표현됨

**예시:**

- **주문(`Order`)** 과 **주문 상세(`OrderDetail`)**  
  주문 상세는 주문의 일부로, 주문 ID를 포함하여 고유하게 식별됩니다.

---

### 비식별관계 (Non-Identifying Relationship)

비식별관계는 자식 엔티티가 **독립적인 기본 키**를 가지며, 부모 엔티티와의 관계가 존재하더라도 그 관계가 기본 키에 포함되지 않는 경우를 말합니다.  
따라서 자식 엔티티는 부모 엔티티 없이도 독립적으로 존재할 수 있습니다.

**특징:**

- 자식 엔티티의 기본 키는 부모 엔티티의 기본 키를 포함하지 않음
- 부모와의 관계가 있으나, 자식 엔티티는 독립적으로 존재 가능함
- ER 다이어그램에서는 **점선**으로 표현됨

**예시:**

- **사용자(`User`)** 와 **프로필(`Profile`)**  
  프로필은 사용자의 정보를 참조하지만, 자체적으로 고유한 ID를 가지고 독립적으로 관리될 수 있습니다.

---

## 결론

식별자와 비식별자, 그리고 식별관계와 비식별관계는 데이터베이스 설계 및 ER 다이어그램 작성에 있어 핵심적인 개념입니다.  
이들을 잘 이해하면 엔티티 간의 관계를 명확하게 모델링하고 데이터 무결성을 효과적으로 유지할 수 있습니다.

<br>
<br>

## 2025.03.07 (FRI)

### ✅ Today I've done

- 국토교통부 자동차종합정보 API 조사

<br>

### ❣️ Today I've Learned

### 1. 개요

- **API 명칭:** 국토교통부 자동차종합정보 API
- **제공 기관:** 국토교통부 및 관련 정부 부처
- **주요 목적:** 차량의 기본 정보(등록번호, 차대번호, 제조사 등)를 제공하여 차량 관련 데이터를 조회할 수 있음

### 2. 주요 특징

- **데이터 언어:**
  - 기본적으로 한글로 응답 데이터를 제공함
  - 일부 입력 데이터나 특정 상황에 따라 영문 정보가 포함될 수 있음
- **응답 구조:**
  - **header:** API 호출 결과에 대한 상태 정보 제공
    - 예: `resultCode`, `resultMsg`
  - **body:** 실제 차량 정보 데이터 포함
    - `items`: 차량 정보 목록 (배열 형태)
    - `pageNo`: 현재 페이지 번호 (페이징 처리 지원)
    - `totalCount`: 전체 검색 결과 건수

### 3. JSON 응답 예시

```json
{
  "header": {
    "resultCode": "00",
    "resultMsg": "NORMAL SERVICE."
  },
  "body": {
    "items": [
      {
        "차량번호": "12가3456",
        "차대번호": "XXXXXXXXXX",
        "모델명": "SM5",
        "제조사": "르노삼성",
        "연식": "2018",
        "색상": "검정",
        "배기량": "2000",
        "연료종류": "가솔린",
        "검사일자": "2022-06-01"
      }
    ],
    "pageNo": 1,
    "totalCount": 100
  }
}
```

<br>
<br>

## 2025.03.06 (THU)

### ✅ Today I've done

- OBD2, ELM327, DTC

<br>

### ❣️ Today I've Learned

### OBD2 (On-Board Diagnostics 2)

- **정의:** 차량의 센서 데이터를 수집하고 ECU의 상태를 모니터링하는 표준 진단 시스템
- **주요 기능:**
  - 실시간 데이터 모니터링
  - 문제 발생 시 오류 코드 기록 및 진단
  - 배기가스 규제 준수를 위한 검사 지원
- **특징:** 미국 등 여러 국가에서 의무화되어 다양한 차량에서 일관된 방식으로 사용

### ELM327

- **정의:** OBD2 포트와 차량의 ECU 간 통신을 위한 인터페이스 칩 및 프로토콜
- **주요 기능:**
  - 차량의 OBD2 데이터를 읽어들여 컴퓨터나 스마트폰에 전송
  - 블루투스, Wi-Fi, USB 등 다양한 연결 방식을 지원
  - 여러 제조사의 통신 프로토콜에 대응하여 광범위한 차량 호환성 제공

### DTC (Diagnostic Trouble Code)

- **정의:** 차량의 ECU가 이상을 감지할 때 생성되는 오류 식별 코드
- **주요 기능:**
  - 센서 데이터 이상 및 결함 감지 시 코드 기록
  - 오류의 원인을 파악하는 데 도움
  - 정비 및 수리 시 진단 정보로 활용

<br>
<br>

## 2025.03.05 (Wed)

### ✅ Today I've done

- Mobile 환경에서 Redis Pub/Sub과 WebSocket 사용 기술 분석

<br>

### ❣️ Today I've Learned

### 1. Redis Pub/Sub의 역할 (주로 서버 사이드)

- **서버 중심 메시징:**
  Redis Pub/Sub은 서버 간의 실시간 메시지 브로드캐스팅에 최적화되어 있습니다. 모바일 클라이언트가 직접 Redis에 접속하는 경우는 드물며, 보안 및 네트워크 제약 때문에 대부분의 경우 백엔드에서 Redis로 메시지를 받고 이를 다른 프로토콜(예: WebSocket)을 통해 전달합니다.

- **높은 처리량 및 확장성:**
  Redis는 인메모리 방식으로 많은 양의 메시지를 빠르게 처리할 수 있어, 백엔드에서 대규모 이벤트 분배나 알림 시스템 구현에 적합합니다.

- **비영속적 특성:**
  메시지가 지속되지 않으므로, 구독자가 연결되어 있어야 실시간 메시지를 받을 수 있습니다. 이 점은 모바일처럼 연결이 간헐적인 환경에서 직접 사용하기에는 한계가 있습니다.

### 2. WebSocket의 역할 (모바일 클라이언트와의 연결)

- **양방향 통신:**
  WebSocket은 모바일 기기와 서버 간에 지속적이고 양방향 통신 채널을 제공합니다. 이를 통해 서버는 실시간으로 업데이트를 푸시할 수 있으며, 모바일 클라이언트는 즉각적으로 반응할 수 있습니다.

- **연결 유지 및 재연결:**
  모바일 네트워크는 불안정할 수 있으므로, WebSocket 클라이언트는 연결 상태를 모니터링하고 필요 시 재연결 로직(heartbeat, ping/pong 등)을 구현해야 합니다.

- **보안 및 프로토콜:**
  WebSocket은 WSS(보안 WebSocket)를 사용하여 HTTPS와 유사한 보안 수준을 제공하며, 이는 모바일 앱에서 중요하게 고려해야 할 요소입니다.

- **자원 효율성:**
  지속적인 연결을 유지하는 동안 배터리와 데이터 사용을 최적화할 필요가 있습니다. 이는 전송되는 데이터의 양과 heartbeat 빈도 조절 등을 통해 관리합니다.

### 3. Redis Pub/Sub과 WebSocket의 통합 활용

- **아키텍처 분리:**

  - **백엔드:** Redis Pub/Sub을 사용하여 이벤트나 메시지를 받아 여러 서버 혹은 프로세스로 분산합니다.
  - **메시지 브로커:** Redis에서 받은 메시지를 WebSocket 서버를 통해 모바일 클라이언트로 전달합니다.

- **확장성 및 안정성:**

  - Redis는 대량의 이벤트를 효율적으로 처리하며, WebSocket 서버는 클라이언트 연결을 관리합니다.
  - 만약 WebSocket 연결이 끊기더라도, 모바일 앱은 재연결 후 누락된 데이터를 REST API 등 다른 방법으로 복구할 수 있습니다.

- **실시간 대응:**
  이 조합을 통해 서버는 높은 처리량의 메시지를 Redis로 분산 처리하고, 모바일 클라이언트는 WebSocket을 통해 실시간으로 데이터를 전달받아 사용자에게 빠른 피드백을 제공할 수 있습니다.

### 결론

- **Redis Pub/Sub**은 주로 서버 사이드에서 높은 처리량과 확장성을 제공하는 메시지 브로커로 사용되며, 모바일 환경에서는 직접 연결보다는 백엔드 메시징 분배에 활용됩니다.
- **WebSocket**은 모바일 기기와 서버 간의 안정적인 실시간 양방향 통신을 가능하게 하여, 불안정한 네트워크 환경에서도 사용자 경험을 향상시킵니다.
- 두 기술을 적절히 결합함으로써, 모바일 애플리케이션에서 실시간 데이터 전달과 효율적인 리소스 관리를 동시에 달성할 수 있습니다.

<br>
<br>

## 2025.03.04 (Tue)

### ✅ Today I've done

- Kafka vs Redis pub/sub

<br>

### ❣️ Today I've Learned

**1. Apache Kafka**

- **아키텍처:** 분산 시스템, 로그 기반 메시지 저장소
- **특징:**
  - 높은 처리량과 낮은 지연시간
  - 메시지 지속 저장 및 재생 기능
  - 내결함성 및 확장성 우수
- **사용 사례:** 이벤트 소싱, 로그 집계, 실시간 스트리밍 분석

**2. Redis Pub/Sub**

- **아키텍처:** 인메모리 기반 메시지 브로커
- **특징:**
  - 매우 낮은 지연시간과 빠른 메시지 전달
  - 메시지가 지속되지 않으며, 구독자에게 실시간으로 전달 후 사라짐
  - 상대적으로 간단하고 설정이 쉬움
- **사용 사례:** 실시간 채팅, 알림 시스템, 간단한 이벤트 브로드캐스팅

**3. 비교 요약**

- **확장성:**
  - Kafka는 파티셔닝과 클러스터링을 통한 수평 확장이 용이
  - Redis는 단순하지만 대규모 처리에는 별도 클러스터링 구성이 필요
- **내구성:**
  - Kafka는 메시지 지속 저장을 통해 내구성과 재생 기능 제공
  - Redis Pub/Sub은 메시지가 영속적으로 저장되지 않음
- **지연시간:**
  - Redis는 인메모리 처리로 극히 낮은 지연시간 제공
  - Kafka는 디스크 I/O가 포함되지만 최적화된 환경에서 충분히 낮은 지연시간 유지
- **복잡성:**
  - Kafka는 설치 및 운영 관리가 복잡할 수 있음
  - Redis Pub/Sub은 간단하게 구성하고 사용할 수 있음

**4. 결론**

- **Kafka:** 신뢰성 높은 메시지 저장, 재생 및 대규모 데이터 스트리밍 처리에 적합
- **Redis Pub/Sub:** 경량 실시간 메시징에 적합하며, 단순한 이벤트 브로드캐스팅에 효과적

<br>
<br>
```
